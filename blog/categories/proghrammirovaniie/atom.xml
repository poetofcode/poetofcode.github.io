<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: программирование | PoetOfCode' Blog]]></title>
  <link href="http://poetofcode.ru/blog/categories/proghrammirovaniie/atom.xml" rel="self"/>
  <link href="http://poetofcode.ru/"/>
  <updated>2015-04-03T17:24:35+04:00</updated>
  <id>http://poetofcode.ru/</id>
  <author>
    <name><![CDATA[PoetOfCode]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Пакеты в Golang]]></title>
    <link href="http://poetofcode.ru/blog/2015/04/03/pakiety-v-golang/"/>
    <updated>2015-04-03T17:09:03+04:00</updated>
    <id>http://poetofcode.ru/blog/2015/04/03/pakiety-v-golang</id>
    <content type="html"><![CDATA[<p>Модульность приложений в Golang обеспечивается при помощи пакетов (packages) &ndash; логичесих сущностей, которые играют роль одновременно модулей и пространств имён в других языках.</p>

<h3>Про GOPATH</h3>

<p>Вся работа с кодом в Golang происходит в месте, называемом Workspace. На практике это директория на диске, путь к которой необходимо определить в переменной GOPATH в системе.</p>

<p>Эта директория будет иметь следующую структуру:</p>

<pre><code>$GOPATH
    |_ bin
    |_ pkg
    |_ src  
</code></pre>

<ul>
<li><strong>bin</strong> &ndash; сюда будут скопированы запускаемые файлы наших приложений после запуска команды go install.</li>
<li><strong>pkg</strong> &ndash; тут будут содержаться объектные файлы пакетов (статические библиотеки с расширением .a). Во многих других языках соответствующая папка имеет название obj.</li>
<li><strong>src</strong> &ndash; это &ldquo;точка входа&rdquo; для наших исходников. Эта папка будет содержать структуру исходников приложений и библиотек.</li>
</ul>


<!-- more -->


<h3>Что представляют собой пакеты?</h3>

<p>Пакеты в Go больше всего напоминают пакеты в Java: они также представляют собой каталоги, которые находятся в какой-то поддиректории каталога $GOPATH/src. Эти относительные пути (относительно src) и являются уникальными именами пакетов в Go. Правда в отличие от Java, где командой import мы можем указать имена импортируемых классов и уже обращаться к ним в коде напрямую, в Go мы импортируем весь пакет, а уже в коде обращаемся к импортируемым из него сущностям через точку после имени пакета:</p>

<p>```go</p>

<pre><code>package main

import "fmt"

func main() {
    fmt.PrintLn("Hello")
}
</code></pre>

<p>```</p>

<p>Тут &ldquo;fmt&rdquo; &ndash; это не класс, а пакет, который содержит импортируемую функцию PrintLn.</p>

<p>Также в Java разрешается импортировать только публичные классы (с соответствующем модификатором доступа), тогда как в Go будут импортированы все сущности (структуры, переменные, функции/методы), имя которых начинается с заглавной буквы (как функция PrintLn из примера выше).</p>

<p>И ещё одно не совсем очевидное отличие. Как я понимаю, ради упрощения и унификации в Go не различаются понятия библиотеки и пакета: пакет и есть библиотека. Мы можем определить пакет вне нашего приложения (в какой-нибудь директории в src, но выше каталога с кодом программы) и пользоваться точно также в приложении &ndash; просто импортировав пакет по его уникальному пути. В данном случае это и будет аналогом библиотеки в других языках. То есть не нужны никакие другие действия для определения того, что пакет будет являться библиотекой.</p>

<h3>Создание и использование собственных пакетов</h3>

<p>Весь код в программах на Go обязательно распределяется по пакетам. А это значит, что каждый исходный файл начинается со строки:</p>

<p>```go</p>

<pre><code>package package_name
</code></pre>

<p>```</p>

<p>Как говорилось выше уникальность пакета определяется его относительной директорией где-то в $GOPATH/src. Как раз эта директория и указывается при импорте одного пакета из другого.</p>

<p>```go</p>

<pre><code>package main

import "MyFirstApp/Utils"
</code></pre>

<p>```</p>

<p>В данном случае в пакете &ldquo;main&rdquo; происходит импорт сущностей из пакета MyFirstApp/Utils (это значит, что его абсолютный путь &ndash; $GOPATH/src/MyFirstApp/Utils).</p>

<p>В исполняемом приложении должен содержаться пакет &ldquo;main&rdquo;, который в свою очередь будет содержать функцию main() и эта функция будет точкой входа в приложение.</p>

<p>Что касается файлов исходников, в которых будет храниться весь код пакета, то тут есть особенность: неважно какие у них будут имена (главное, что с расширением .go) и неважно сколько их будет, Go все равно будет считать их единым пакетом. Главное условие &ndash; это то что все файлы будут находится в директории пакета и будут начинаться со строки, означающей принадлежность к пакету (package package_name).</p>

<h3>Небольшая особенность с запуском приложений, в которых &ldquo;main&rdquo; распределён по нескольким файлам</h3>

<p>Пакет &ldquo;main&rdquo; как любой другой пакет может быть расположен в нескольких файлах, но есть одна особенность при запуске таких приложений. В Go есть команда go run app.go &ndash; которая неявно компилирует и исполняет приложение. Она требует указания имени файла. так вот в случае, если &ldquo;main&rdquo; распределен по нескольким файлам, то нужно указывать все эти файлы в качестве параметров для go run. Например:</p>

<pre><code>go run app_part1.go app_part2.go
</code></pre>

<h3>Материалы</h3>

<p>Тут содержится официальная информация по теме пакетов (и не только): <a href="http://golang.org/doc/code.html">http://golang.org/doc/code.html</a></p>
]]></content>
  </entry>
  
</feed>
